#lang racket

(require scheme/mpair)

(define (make-table)
  (define table (mlist 'table))
  (define (assoc records key)
    (cond 
      ((null? records) false)
      ((equal? (mcar (mcar records)) key) (mcar records))
      (else (assoc (mcdr records) key)))
    )
  (define (lookup records keys)
    (if (null? keys)
      (mcar records)
      (let ((sub-records (assoc (mcdr records) (car keys))))
        (if sub-records 
          (lookup (mcdr sub-records) (cdr keys))
          false)))
    )
  (define (insert! records keys value)
    (if (null? keys)
      (set-mcar! records value)
      (let ((sub-records (assoc (mcdr records) (car keys))))
        (if (not sub-records)
          (begin (set! sub-records (mlist (car keys) false))
                 (set-mcdr! records (mcons sub-records (mcdr records))))
          sub-records)
        (insert! (mcdr sub-records) (cdr keys) value)))
    )
  (lambda (m . args)
    (cond
      ((eq? m 'lookup) (lookup table args))
      ((eq? m 'insert!) (insert! table (drop-right args 1) (last args)))
      (else (error "invalid message!")))
    )
  )

;
(define t1 (make-table))
(t1 'insert! 1 1)
(t1 'insert! 1 2 12)
(t1 'insert! 1 2 3 123)
(t1 'insert! 1 2 4 124)
(t1 'insert! 1 2 3 4 5 12345)
(t1 'lookup 1)
(t1 'lookup 2)
(t1 'lookup 1 1)
(t1 'lookup 1 2)
(t1 'lookup 1 3)
(t1 'lookup 1 2 3)
(t1 'lookup 1 2 4)
(t1 'lookup 1 2 5)
(t1 'lookup 1 2 3 4)
(t1 'lookup 1 2 3 4 5)
