#lang racket

(define (make-from-real-img x y)
  (lambda (op)
    (cond
      ((eq? 'real-part op) x)
      ((eq? 'imag-part op) y)
      ((eq? 'magnitude op) (sqrt (+ (sqr x) (sqr y))))
      ((eq? 'angle op) (atan (/ y x)))
      (else (error "invalid op" op))
      )
    ))
(define (make-from-mag-ang x y)
  (lambda (op)
    (cond
      ((eq? 'real-part op) (* x (cos y)))
      ((eq? 'imag-part op) (* x (sin y)))
      ((eq? 'magnitude op) x)
      ((eq? 'angle op) y)
      (else (error "invalid op" op))
      )
    ))

(define (add-complex x y)
  (make-from-real-img (+ (x 'real-part) (y 'real-part))
                      (+ (x 'imag-part) (y 'imag-part)))
  )
(define (sub-complex x y)
  (make-from-real-img (- (x 'real-part) (y 'real-part))
                      (- (x 'imag-part) (y 'imag-part)))
  )
(define (mul-complex x y)
  (make-from-mag-ang (* (x 'magnitude) (y 'magnitude))
                     (+ (x 'angle) (y 'angle)))
  )
(define (div-complex x y)
  (make-from-mag-ang (/ (x 'magnitude) (y 'magnitude))
                     (- (x 'angle) (y 'angle)))
  )

(define (print-complex x)
  (pretty-print (list (x 'real-part) (x 'imag-part)))
  )

(define c1 (make-from-real-img 1 2))
(define c2 (make-from-real-img 2 1))
(print-complex (add-complex c1 c2))
(print-complex (sub-complex c1 c2))
(print-complex (mul-complex c1 c2))
(print-complex (div-complex c1 c2))
