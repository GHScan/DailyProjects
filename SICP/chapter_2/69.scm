#lang racket

(provide encode decode generate-huffman-tree generate-message-pairs)

(define (make-leaf-node symbol weight)
  (cons symbol weight)
  )
(define (leaf-node? node)
  (symbol? (car node))
  )
(define (leaf-node-symbol node)
  (car node)
  )
(define (leaf-node-weight node)
  (cdr node)
  )

(define (make-binary-node left right)
  (list left right (+ (node-weight left) (node-weight right)))
  )
(define (binary-node-left node)
  (car node)
  )
(define (binary-node-right node)
  (cadr node)
  )
(define (binary-node-weight node)
  (caddr node)
  )

(define (node-weight node)
  (if (leaf-node? node)
    (leaf-node-weight node)
    (binary-node-weight node))
  )

(define (adjoin-multi-set x set pkey) 
  (cond
    ((null? set) (cons x set))
    ((<= (pkey x) (pkey (car set))) (cons x set))
    (else (cons (car set) (adjoin-multi-set x (cdr set) pkey))))
  )

(define (make-leaf-set pairs)
  (foldr (lambda (x init) (adjoin-multi-set x init leaf-node-weight)) 
         empty
         (map (lambda (p) (make-leaf-node (car p) (cadr p))) pairs))
  )
(define (successive-merge nodes)
  (if (= 1 (length nodes))
    (car nodes)
    (successive-merge
      (adjoin-multi-set (make-binary-node (list-ref nodes 1) (list-ref nodes 0))
                        (list-tail nodes 2)
                        node-weight))
    )
  )
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs))
  )

(define (generate-message-pairs message)
 (define (adjoin-symbol-to-pairs symbol pairs)
  (cond 
   ((null? pairs) (list (list symbol 1)))
   ((eq? symbol (caar pairs)) (cons (list (caar pairs) (+ 1 (cadar pairs))) (cdr pairs)))
   (else (cons (car pairs) (adjoin-symbol-to-pairs symbol (cdr pairs)))))
  )
 (foldr adjoin-symbol-to-pairs empty message)
 )

(define (encode-symbol symbol nodes)
  (define (encode-symbol-iter symbol node bits)
    (if (leaf-node? node)
      (if (eq? symbol (leaf-node-symbol node)) bits false)
      (or (encode-symbol-iter symbol (binary-node-left node) (cons '0 bits)) 
          (encode-symbol-iter symbol (binary-node-right node) (cons '1 bits))))
    )
  (reverse (encode-symbol-iter symbol nodes empty))
  )
(define (encode message nodes)
  (foldr append 
         empty
         (map (lambda (symbol) (encode-symbol symbol nodes)) message))
  )

(define (decode-symbol bits node)
  (if (leaf-node? node)
    (cons bits (leaf-node-symbol node))
    (decode-symbol (cdr bits)
                   (cond
                     ((= '0 (car bits)) (binary-node-left node))
                     ((= '1 (car bits)) (binary-node-right node))
                     (else (error "invalid bits" (car bits)))))
    )
  )
(define (decode bits nodes)
  (if (null? bits)
    empty
    (let ((result (decode-symbol bits nodes)))
      (cons (cdr result) 
            (decode (car result) nodes))))
  )
