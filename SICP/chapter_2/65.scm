#lang racket

(define (make-node key left right)
  (list key left right)
  )
(define (node-key node)
  (car node)
  )
(define (node-left node)
  (cadr node)
  )
(define (node-right node)
  (caddr node)
  )

(define (union-set set1 set2)
  (define (union-list list1 list2)
    (cond
      ((or (null? list1) (null? list2)) (append list1 list2))
      ((= (car list1) (car list2)) (cons (car list1) (union-list (cdr list1) (cdr list2))))
      ((< (car list1) (car list2)) (cons (car list1) (union-list (cdr list1) list2)))
      (else (cons (car list2) (union-list list1 (cdr list2))))
      )
    )
  (uniq-ordered-list->set (union-list (set->list set1) (set->list set2)))
  )
(define (intersection-set set1 set2)
  (define (intersection-list list1 list2)
    (cond
      ((or (null? list1) (null? list2)) empty)
      ((= (car list1) (car list2)) (cons (car list1) (intersection-list (cdr list1) (cdr list2))))
      ((< (car list1) (car list2)) (intersection-list (cdr list1) list2))
      (else (intersection-list list1 (cdr list2)))
      )
    )
  (uniq-ordered-list->set (intersection-list (set->list set1) (set->list set2)))
  )
(define (element-of-set? x set)
  (cond
    ((null? set) false)
    ((= x (node-key set)) true)
    ((< x (node-key set)) (element-of-set? x (node-left set)))
    (else (element-of-set? x (node-right set))))
  )
(define (adjoin-set x set)
  (cond
    ((null? set) 
     (make-node x empty empty))
    ((= x (node-key set)) 
     set)
    ((< x (node-key set)) 
     (make-node (node-key set) (adjoin-set x (node-left set)) (node-right set)))
    (else 
      (make-node (node-key set) (node-left set) (adjoin-set x (node-right set))))
    )
  )
(define (set->list set)
  (define (node-list node result)
    (if (null? node)
      result
      (node-list (node-left node)
                 (cons (node-key node) 
                       (node-list (node-right node)
                                  result)))
      ))
  (node-list set empty)
  )
(define (uniq-ordered-list->set l)
  (define (iter l n) 
    (if (zero? n)
      (cons l empty)
      (let ((left-result (iter l (quotient n 2))))
        (let ((left-node (cdr left-result))(left-remaining (car left-result)))
          (let ((right-result (iter (cdr left-remaining) (- n (+ 1 (quotient n 2))))))
            (let ((right-node (cdr right-result))(right-remaining (car right-result)))
              (cons right-remaining
                    (make-node (car left-remaining)
                               left-node
                               right-node))))))
      )
    )
  (cdr (iter l (length l)))
  )
(define (list->set l)
  (foldr adjoin-set empty l)
  )
(define (print-set set)
 (pretty-print (set->list set))
 )

(define set1 (list->set '(1 2 2 3 4 4 4 5 5)))
(define set2 (list->set '(6 6 2 4 2 4 6)))
(print-set set1)
(print-set set2)
(pretty-print (element-of-set? 6 set1))
(pretty-print (element-of-set? 6 set2))
(print-set (intersection-set set1 set2))
(print-set (union-set set1 set2))
